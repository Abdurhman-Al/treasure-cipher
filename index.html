<!doctype html>
<html lang="Ø§Ø±" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ù„Ø¹Ø¨Ø© Ø§Ù„ÙƒÙ†Ø² - ØªØ´ÙÙŠØ± Ø§Ù„Ù†Øµ</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Tahoma, Arial; margin: 24px; line-height: 1.6; }
    .card { max-width: 980px; margin: 0 auto; padding: 18px; border: 1px solid #ddd; border-radius: 14px; }
    h1 { margin: 0 0 12px; font-size: 22px; }
    label { display:block; margin: 10px 0 6px; font-weight: 700; }
    textarea, input, select { width: 100%; box-sizing: border-box; padding: 10px; border-radius: 10px; border: 1px solid #ccc; font-size: 15px; }
    /* Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ */
#out.ltr {
  direction: ltr;
  unicode-bidi: plaintext;
  text-align: left;
}
#out.rtl {
  direction: rtl;
  unicode-bidi: plaintext;
  text-align: right;
}

    textarea { min-height: 110px; resize: vertical; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .btns { display:flex; gap:10px; flex-wrap: wrap; margin-top: 12px; }
    button { padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer; font-weight: 800; }
    button.primary { background: #111; color: #fff; }
    button.secondary { background: #eee; }
    .hint { color:#555; font-size: 13px; margin-top: 6px; }
    .small { font-size: 12px; color:#666; }
    .hr { height:1px; background:#eee; margin:16px 0; }

    .toggle { display:flex; align-items:center; justify-content: space-between; gap:10px; }
    .panel { border:1px dashed #ddd; border-radius: 12px; padding: 14px; background:#fafafa; display:none; margin-top: 10px; }
    .panel.open { display:block; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#f2f2f2; padding:8px; border-radius:10px; white-space: pre-wrap; }

    .boxes { display:flex; gap:10px; flex-wrap: wrap; margin-top: 8px; }
    .boxword { border:1px solid #bbb; border-radius: 10px; padding:10px 12px; background:#fff; font-weight:800; letter-spacing: 0.5px; }
    .muted { color:#777; font-weight:600; font-size: 12px; }

    code { background:#f6f6f6; padding: 2px 6px; border-radius: 6px; }
    @media (max-width: 800px){ .row{grid-template-columns: 1fr;} }
  </style>
</head>
<body>
  <div class="card">
    <h1>ğŸ” Ù„Ø¹Ø¨Ø© Ø§Ù„ÙƒÙ†Ø² â€” ØªØ´ÙÙŠØ± / ÙÙƒ ØªØ´ÙÙŠØ± Ø§Ù„Ù†Øµ</h1>

    <label>Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ</label>
    <textarea id="plain" placeholder="Ù…Ø«Ø§Ù„: ØªØ¬Ø¯ Ø§Ù„ÙƒÙ†Ø² ÙÙŠ ØµØ§Ù„Ø© Ø§Ù„Ø¨ÙŠØª"></textarea>

    <div class="row">
      <div>
        <label>Ù†ÙˆØ¹ Ø§Ù„Ø´ÙØ±Ø©</label>
        <select id="mode">
          <option value="arabic_numbers">1) ØªØ±Ù‚ÙŠÙ… Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø§=1...)</option>
          <option value="polybius_ar">2) Polybius Ø¹Ø±Ø¨ÙŠ (Ø±Ù‚Ù…ÙŠÙ† Ù„ÙƒÙ„ Ø­Ø±Ù)</option>
          <option value="keyed_numbers">3) ØªØ´ÙÙŠØ± Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù…Ø¹ Ù…ÙØªØ§Ø­</option>
          <option value="caesar_ar">4) Ù‚ÙŠØµØ± Ø¹Ø±Ø¨ÙŠ (Ø¥Ø²Ø§Ø­Ø©)</option>
          <option value="vigenere_ar">5) VigenÃ¨re Ø¹Ø±Ø¨ÙŠ (Ù…ÙØªØ§Ø­ ÙƒÙ„Ù…Ø©)</option>
          <option value="atbash_ar">6) Atbash Ø¹Ø±Ø¨ÙŠ (Ø¹ÙƒØ³ Ø§Ù„Ø­Ø±ÙˆÙ)</option>
          <option value="base64">7) Base64 Ù„Ù„Ù†Øµ</option>
        </select>
        <div class="hint" id="modeHint"></div>
      </div>

      <div>
        <label>Ø§Ù„Ù…ÙØªØ§Ø­ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ø­Ø³Ø¨ Ø§Ù„Ø´ÙØ±Ø©)</label>
        <input id="key" placeholder="Ù‚ÙŠØµØ±: Ø±Ù‚Ù… Ù…Ø«Ù„ 3 â€” VigenÃ¨re: ÙƒÙ„Ù…Ø© Ù…Ø«Ù„ ÙƒÙ†Ø²" />
        <div class="small">Ù…Ù„Ø§Ø­Ø¸Ø©: â€œØªØ´ÙÙŠØ± Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù…Ø¹ Ù…ÙØªØ§Ø­â€ Ù„Ù‡ Ø¥Ø¹Ø¯Ø§Ø¯Ø§ØªÙ‡ ØªØ­Øª.</div>
      </div>
    </div>

    <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªØ´ÙÙŠØ± Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù…Ø¹ Ù…ÙØªØ§Ø­ -->
    <div id="keyedControls" style="margin-top:12px; display:none;">
      <div class="hr"></div>
      <label>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªØ´ÙÙŠØ± Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù…Ø¹ Ù…ÙØªØ§Ø­</label>

      <label>Ù†Ù…Ø· Ø§Ù„Ù…ÙØªØ§Ø­</label>
      <select id="mapStyle">
        <option value="seq">ØªØ³Ù„Ø³Ù„ÙŠ: Ø§=1ØŒ Ø¨=2â€¦</option>
        <option value="rev">Ù…Ø¹ÙƒÙˆØ³: Ø§=28ØŒ Ø¨=27â€¦</option>
        <option value="interleave">Ù…ØªÙ†Ø§ÙˆØ¨: Ø§=1ØŒ Ø¨=15ØŒ Øª=2ØŒ Ø«=16â€¦</option>
      </select>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Ø¹Ø¯Ø¯ Ø£Ø²ÙˆØ§Ø¬ â€œØ§Ù„ØªÙ„Ù…ÙŠØ­â€ Ù„Ù„Ø·Ø¨Ø§Ø¹Ø©</label>
          <input id="hintCount" type="number" min="2" max="28" value="6" />
          <div class="small">Ù…Ø«Ù„Ø§Ù‹ 6 â†’ ÙŠØ·Ø¨Ø¹ 6 Ø£Ø²ÙˆØ§Ø¬ ÙÙ‚Ø·: Ø§=1ØŒ Ø¨=15â€¦</div>
        </div>
        <div>
          <label>Ø²Ø± ØªØ¬Ù‡ÙŠØ² Ø§Ù„ØªÙ„Ù…ÙŠØ­</label>
          <div class="btns" style="margin-top:0;">
            <button class="secondary" id="genHintBtn">ØªÙˆÙ„ÙŠØ¯ ØªÙ„Ù…ÙŠØ­</button>
            <button class="secondary" id="genFullKeyBtn">ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…ÙØªØ§Ø­ ÙƒØ§Ù…Ù„ (Ù„Ù„Ù…Ù†Ø¸Ù‘Ù…)</button>
          </div>
        </div>
      </div>

      <label>Ù†Øµ Ø§Ù„ØªÙ„Ù…ÙŠØ­ (ØªÙ‚Ø¯Ø± ØªØ¹Ø¯Ù„Ù‡ ÙŠØ¯ÙˆÙŠÙ‹Ø§)</label>
      <textarea id="hintText" placeholder="Ù…Ø«Ø§Ù„: Ø§=1ØŒ Ø¨=15ØŒ Øª=2ØŒ Ø«=16..."></textarea>

      <label>Ø§Ù„Ù…ÙØªØ§Ø­ ÙƒØ§Ù…Ù„ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ â€“ Ù„Ù„Ù…Ù†Ø¸Ù‘Ù… ÙÙ‚Ø·)</label>
      <textarea id="fullKeyText" placeholder="Ø³ÙŠØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø§Ù„Ù…ÙØªØ§Ø­ ÙƒØ§Ù…Ù„ Ø¥Ø°Ø§ Ø¶ØºØ·Øª Ø²Ø± Ø§Ù„ØªÙˆÙ„ÙŠØ¯"></textarea>
    </div>

    <div class="btns">
      <button class="primary" id="encryptBtn">Ø´ÙÙ‘Ø±</button>
      <button class="secondary" id="decryptBtn">ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ±</button>
      <button class="secondary" id="copyBtn">Ù†Ø³Ø® Ø§Ù„Ù†Ø§ØªØ¬</button>
      <button class="secondary" id="swapBtn">Ø¨Ø¯Ù‘Ù„ (Ø§Ù„Ù†Ø§ØªØ¬ â† Ø§Ù„Ù†Øµ)</button>
      <button class="secondary" id="clearBtn">Ù…Ø³Ø­</button>
      <button class="secondary" id="printBtn">ğŸ–¨ï¸ Ø·Ø¨Ø§Ø¹Ø© Ø¨Ø·Ø§Ù‚Ø©</button>
    </div>

    <div style="margin-top:10px;">
      <label style="display:flex; gap:10px; align-items:center; font-weight:700;">
        <input type="checkbox" id="printFullKey" />
        Ø§Ø·Ø¨Ø¹ Ø§Ù„Ù…ÙØªØ§Ø­ ÙƒØ§Ù…Ù„ (Ù„Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„ØµØ¹Ø¨Ø©)
      </label>

      <label style="display:flex; gap:10px; align-items:center; font-weight:700;">
        <input type="checkbox" id="printBoxes" checked />
        Ø§Ø·Ø¨Ø¹ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø¯Ø§Ø®Ù„ ØµÙ†Ø§Ø¯ÙŠÙ‚ (Ø¨Ø¯Ù„ Ø³Ø·Ø± ÙˆØ§Ø­Ø¯)
      </label>
      <div class="small">Ø§Ù„ÙƒÙ„Ù…Ø§Øª ØªÙÙØµÙ„ Ø¨Ù€ <code>|</code>ØŒ ÙˆÙ‡Ø°Ø§ Ø§Ù„Ø®ÙŠØ§Ø± ÙÙ‚Ø· Ù„Ø·Ø±ÙŠÙ‚Ø© Ø¹Ø±Ø¶Ù‡Ø§ ÙÙŠ Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©.</div>
    </div>

    <label>Ø§Ù„Ù†Ø§ØªØ¬</label>
    <textarea id="out" placeholder="Ø³ÙŠØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø´ÙÙ‘Ø± Ø£Ùˆ Ø§Ù„Ù…ÙÙƒÙˆÙƒ"></textarea>

    <div class="muted" id="previewLabel" style="margin-top:10px; display:none;">Ù…Ø¹Ø§ÙŠÙ†Ø© (ÙƒÙ„Ù…Ø§Øª Ø¯Ø§Ø®Ù„ ØµÙ†Ø§Ø¯ÙŠÙ‚):</div>
    <div class="boxes" id="previewBoxes" style="display:none;"></div>

    <div class="hr"></div>

    <div class="toggle">
      <div style="font-weight:800;">ğŸ“˜ Ø´Ø±Ø­ Ø§Ù„ØªØ´ÙÙŠØ± (Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…/Ø§Ù„ØªØ¬Ø±Ø¨Ø©)</div>
      <button class="secondary" id="toggleHelpBtn">Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø´Ø±Ø­</button>
    </div>
    <div class="panel" id="helpPanel">
      <div class="mono" id="helpText">Ø§Ø®ØªÙØ± Ù†ÙˆØ¹ Ø§Ù„Ø´ÙØ±Ø© Ù„ØªØ¸Ù‡Ø± Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø¨Ø³ÙŠØ·Ø© Ù‡Ù†Ø§.</div>
    </div>
  </div>

<script>
/** ===== Arabic alphabet ===== */
const ALPH = "Ø§Ø¨ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹ØºÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙŠ";
const normMap = new Map([["Ø£","Ø§"],["Ø¥","Ø§"],["Ø¢","Ø§"],["Ù±","Ø§"],["Ø©","Ù‡"],["Ù‰","ÙŠ"]]);
const norm = ch => normMap.get(ch) ?? ch;
const isAr = ch => ALPH.includes(norm(ch));
const idxOf = ch => ALPH.indexOf(norm(ch));
function shiftAr(ch, s){
  const c = norm(ch); const i = ALPH.indexOf(c);
  if (i === -1) return ch;
  const n = ALPH.length;
  return ALPH[(i + ((s % n)+n)) % n];
}

/** ===== 1) Arabic numbering with '-' and words '|' ===== */
function arabicToNumbers(text){
  const parts=[];
  for (const ch of text){
    if (isAr(ch)) parts.push(String(idxOf(ch)+1));
    else if (ch === " ") parts.push("|"); // ÙØ§ØµÙ„ ÙƒÙ„Ù…Ø§Øª
    else parts.push(ch);
  }
  return parts.join("-");
}

function numbersToArabic(text){
  const tokens=text.split("-");
  let out="";
  for (const t of tokens){
    if (t==="|"){ out+=" "; continue; }
    if (/^\d+$/.test(t)){
      const n=parseInt(t,10);
      out += (n>=1 && n<=ALPH.length) ? ALPH[n-1] : t;
    } else out += t;
  }
  return out;
}

/** ===== 2) Polybius (6x5) -> pairs, words '|' ===== */
const POLY_COLS = 5;
function polybiusEncode(text){
  return text.split(" ").map(w=>{
    let s="";
    for (const ch0 of w){
      const ch = norm(ch0);
      const i = ALPH.indexOf(ch);
      if (i === -1) s += "_" + ch0 + "_";
      else {
        const r = Math.floor(i / POLY_COLS) + 1;
        const c = (i % POLY_COLS) + 1;
        s += ""+r+c;
      }
    }
    return s;
  }).join("|");
}
function polybiusDecode(text){
  return text.split("|").map(w=>{
    let out="", i=0;
    while (i < w.length){
      if (w[i] === "_"){
        const j = w.indexOf("_", i+1);
        if (j !== -1){ out += w.slice(i+1, j); i = j+1; continue; }
      }
      const a=w[i], b=w[i+1];
      if (!a || !b) break;
      if (/\d/.test(a) && /\d/.test(b)){
        const r=parseInt(a,10), c=parseInt(b,10);
        const k=(r-1)*POLY_COLS + (c-1);
        out += (k>=0 && k<ALPH.length) ? ALPH[k] : "ï¿½";
        i += 2;
      } else { out += w[i]; i += 1; }
    }
    return out;
  }).join(" ");
}

/** ===== 3) Keyed numbers mapping (3 styles you asked) ===== */
function makeOrder(style){
  const base = ALPH.split("");
  if (style === "rev") return [...base].reverse();
  if (style === "interleave"){
    const half = Math.ceil(base.length/2); // 14
    const A = base.slice(0, half);
    const B = base.slice(half);
    const out=[];
    for (let i=0;i<half;i++){
      if (A[i]) out.push(A[i]);
      if (B[i]) out.push(B[i]);
    }
    return out; // 1,15,2,16...
  }
  return base; // seq
}
function makeMapping(style){
  const order = makeOrder(style);
  const map = new Map();
  const inv = new Map();
  for (let i=0;i<order.length;i++){
    const num=i+1; // 1..28
    map.set(order[i], num);
    inv.set(num, order[i]);
  }
  return {order,map,inv};
}
function keyedEncode(text, style){
  const {map} = makeMapping(style);
  return text.split(" ").map(w=>{
    let s="";
    for (const ch0 of w){
      const ch = norm(ch0);
      if (ALPH.includes(ch)) s += String(map.get(ch));
      else s += "_" + ch0 + "_";
    }
    return s;
  }).join("|");
}
function keyedDecode(text, style){
  const {inv} = makeMapping(style);
  return text.split("|").map(w=>{
    let out="", i=0;
    while (i<w.length){
      if (w[i]==="_"){
        const j=w.indexOf("_", i+1);
        if (j!==-1){ out+=w.slice(i+1,j); i=j+1; continue; }
      }
      // try 2-digit 10..28
      if (i+1<w.length && /\d/.test(w[i]) && /\d/.test(w[i+1])){
        const two=parseInt(w.slice(i,i+2),10);
        if (two>=10 && two<=28){ out += inv.get(two)||"ï¿½"; i+=2; continue; }
      }
      // 1-digit 1..9
      if (/\d/.test(w[i])){
        const one=parseInt(w[i],10);
        if (one>=1 && one<=9){ out += inv.get(one)||"ï¿½"; i+=1; continue; }
      }
      out += w[i]; i+=1;
    }
    return out;
  }).join(" ");
}
function buildHint(style, count){
  const {order,map}=makeMapping(style);
  const n=Math.max(2, Math.min(28, parseInt(count,10)||6));
  return order.slice(0,n).map(ch=>`${ch}=${map.get(ch)}`).join("ØŒ ");
}
function buildFullKey(style){
  const {order,map}=makeMapping(style);
  return order.map(ch=>`${ch}=${map.get(ch)}`).join("ØŒ ");
}

/** ===== 4) Caesar ===== */
function caesarEncrypt(text, k){
  const s=parseInt(k,10);
  if (Number.isNaN(s)) return "âš ï¸ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù…Ù‹Ø§ (Ù…Ø«Ù„ 3)";
  let out=""; for (const ch of text) out += shiftAr(ch, s);
  return out;
}
function caesarDecrypt(text, k){
  const s=parseInt(k,10);
  if (Number.isNaN(s)) return "âš ï¸ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù…Ù‹Ø§ (Ù…Ø«Ù„ 3)";
  let out=""; for (const ch of text) out += shiftAr(ch, -s);
  return out;
}

/** ===== 5) VigenÃ¨re ===== */
function vigenereEncrypt(text, keyWord){
  keyWord=(keyWord||"").trim();
  if (!keyWord) return "âš ï¸ Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ù…ÙØªØ§Ø­";
  const shifts=[];
  for (const ch of keyWord) if (isAr(ch)) shifts.push(idxOf(ch));
  if (!shifts.length) return "âš ï¸ Ø§Ù„Ù…ÙØªØ§Ø­ Ù„Ø§Ø²Ù… Ø¹Ø±Ø¨ÙŠ";
  let out="", ki=0;
  for (const ch of text){
    if (isAr(ch)){ out += shiftAr(ch, shifts[ki%shifts.length]); ki++; }
    else out += ch;
  }
  return out;
}
function vigenereDecrypt(text, keyWord){
  keyWord=(keyWord||"").trim();
  if (!keyWord) return "âš ï¸ Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ù…ÙØªØ§Ø­";
  const shifts=[];
  for (const ch of keyWord) if (isAr(ch)) shifts.push(idxOf(ch));
  if (!shifts.length) return "âš ï¸ Ø§Ù„Ù…ÙØªØ§Ø­ Ù„Ø§Ø²Ù… Ø¹Ø±Ø¨ÙŠ";
  let out="", ki=0;
  for (const ch of text){
    if (isAr(ch)){ out += shiftAr(ch, -shifts[ki%shifts.length]); ki++; }
    else out += ch;
  }
  return out;
}

/** ===== 6) Atbash ===== */
function atbash(text){
  const n=ALPH.length;
  let out="";
  for (const ch0 of text){
    const ch=norm(ch0);
    const i=ALPH.indexOf(ch);
    out += (i===-1) ? ch0 : ALPH[(n-1)-i];
  }
  return out;
}

/** ===== 7) Base64 ===== */
function toBase64Unicode(str){
  const utf8 = encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (_,p)=>String.fromCharCode(parseInt(p,16)));
  return btoa(utf8);
}
function fromBase64Unicode(b64){
  const bytes=atob(b64);
  const esc=Array.from(bytes, c=>"%" + c.charCodeAt(0).toString(16).padStart(2,"0")).join("");
  return decodeURIComponent(esc);
}

/** ===== UI ===== */
const elPlain = document.getElementById("plain");
const elOut   = document.getElementById("out");
const elMode  = document.getElementById("mode");
const elKey   = document.getElementById("key");
const elHint  = document.getElementById("modeHint");
const keyedControls = document.getElementById("keyedControls");
const helpPanel = document.getElementById("helpPanel");
const helpText = document.getElementById("helpText");
const toggleHelpBtn = document.getElementById("toggleHelpBtn");
const previewLabel = document.getElementById("previewLabel");
const previewBoxes = document.getElementById("previewBoxes");

function updateHint(){
  const m=elMode.value;
  const hints={
    arabic_numbers:"ÙƒÙ„ Ø­Ø±Ù â†’ Ø±Ù‚Ù… (Ù…Ø¹ -) ÙˆØ§Ù„ÙƒÙ„Ù…Ø§Øª ØªÙØµÙ„ Ø¨Ù€ |",
    polybius_ar:"ÙƒÙ„ Ø­Ø±Ù â†’ Ø±Ù‚Ù…ÙŠÙ† (ØµÙ+Ø¹Ù…ÙˆØ¯)ØŒ ÙˆØ§Ù„ÙƒÙ„Ù…Ø§Øª ØªÙØµÙ„ Ø¨Ù€ |",
    keyed_numbers:"ÙƒÙ„ Ø­Ø±Ù â†’ Ø±Ù‚Ù… Ø­Ø³Ø¨ Ø§Ù„Ù…ÙØªØ§Ø­ (3 Ø£Ù†Ù…Ø§Ø·)ØŒ ÙˆØ§Ù„ÙƒÙ„Ù…Ø§Øª ØªÙØµÙ„ Ø¨Ù€ |",
    caesar_ar:"Ø­Ø±ÙˆÙ (Ø¥Ø²Ø§Ø­Ø©). Ø§Ù„Ù…ÙØªØ§Ø­ Ø±Ù‚Ù…",
    vigenere_ar:"Ø­Ø±ÙˆÙ. Ø§Ù„Ù…ÙØªØ§Ø­ ÙƒÙ„Ù…Ø© Ø¹Ø±Ø¨ÙŠØ©",
    atbash_ar:"Ø­Ø±ÙˆÙ (Ø¹ÙƒØ³). Ø¨Ø¯ÙˆÙ† Ù…ÙØªØ§Ø­",
    base64:"ØªØ±Ù…ÙŠØ² Ù†ØµÙŠ Ù„Ù„Ù†Ø³Ø®/Ø§Ù„Ø¥Ø±Ø³Ø§Ù„"
  };
  elHint.textContent = hints[m] || "";
}
function updateKeyedVisibility(){
  keyedControls.style.display = (elMode.value === "keyed_numbers") ? "block" : "none";
}
function renderBoxesPreview(){
  const v=(elOut.value||"").trim();
  if (!v.includes("|")){
    previewLabel.style.display="none";
    previewBoxes.style.display="none";
    previewBoxes.innerHTML="";
    return;
  }
  const words=v.split("|").filter(Boolean);
  previewBoxes.innerHTML = words.map(w=>`<div class="boxword">${w}</div>`).join("");
  previewLabel.style.display="block";
  previewBoxes.style.display="flex";
}
function updateHelp(){
  const m=elMode.value;
  if (m==="arabic_numbers") helpText.textContent="ØªØ±Ù‚ÙŠÙ… Ø¨Ø³ÙŠØ·: Ø§=1ØŒ Ø¨=2â€¦ Ø§Ù„ÙƒÙ„Ù…Ø§Øª ØªÙØµÙ„ Ø¨Ù€ |ØŒ ÙˆØ§Ù„Ø£Ø±Ù‚Ø§Ù… ØªÙØµÙ„ Ø¨Ù€ -";
  else if (m==="polybius_ar") helpText.textContent="Polybius: ÙƒÙ„ Ø­Ø±Ù Ø±Ù‚Ù…ÙŠÙ† (ØµÙ+Ø¹Ù…ÙˆØ¯). Ø¯Ø§Ø®Ù„ Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„Ø£Ø²ÙˆØ§Ø¬ Ù…ØªØµÙ„Ø©ØŒ ÙˆØ¨ÙŠÙ† Ø§Ù„ÙƒÙ„Ù…Ø§Øª |";
  else if (m==="keyed_numbers") helpText.textContent="Ù‡Ø°Ø§ Ø§Ù„Ù„ÙŠ ØªØ³ØªØ®Ø¯Ù…Ù‡: ØªØ¹Ø·ÙŠ Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ ØªÙ„Ù…ÙŠØ­ Ù…Ø«Ù„: Ø§=1ØŒ Ø¨=15â€¦ ÙˆÙ‡Ùˆ ÙŠØ³ØªÙ†ØªØ¬ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©.";
  else if (m==="caesar_ar") helpText.textContent="Ù‚ÙŠØµØ±: ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø­Ø±ÙˆÙ Ø¨Ø¹Ø¯Ø¯ Ø«Ø§Ø¨Øª (Ø§Ù„Ù…ÙØªØ§Ø­ Ø±Ù‚Ù…).";
  else if (m==="vigenere_ar") helpText.textContent="VigenÃ¨re: Ù…ÙØªØ§Ø­ ÙƒÙ„Ù…Ø© Ø¹Ø±Ø¨ÙŠØ© ÙŠØ¹Ø·ÙŠ Ø¥Ø²Ø§Ø­Ø§Øª Ù…Ø®ØªÙ„ÙØ©.";
  else if (m==="atbash_ar") helpText.textContent="Atbash: Ø¹ÙƒØ³ Ø§Ù„Ø­Ø±ÙˆÙ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø£Ø¨Ø¬Ø¯ÙŠØ©.";
  else helpText.textContent="Base64: ØªØ±Ù…ÙŠØ² Ù„Ù„Ù†Ø³Ø®ØŒ Ù„ÙŠØ³ Ù„ØºØ² Ù‚ÙˆÙŠ.";
}

function encrypt(){
  const text=elPlain.value;
  const m=elMode.value;
  if (m==="arabic_numbers") elOut.value = arabicToNumbers(text);
  else if (m==="polybius_ar") elOut.value = polybiusEncode(text);
  else if (m==="keyed_numbers"){
    const style=document.getElementById("mapStyle").value;
    elOut.value = keyedEncode(text, style);
    updateOutDirection();
  }
  else if (m==="caesar_ar") elOut.value = caesarEncrypt(text, elKey.value);
  else if (m==="vigenere_ar") elOut.value = vigenereEncrypt(text, elKey.value);
  else if (m==="atbash_ar") elOut.value = atbash(text);
  else if (m==="base64") elOut.value = toBase64Unicode(text);
  renderBoxesPreview();
}
function decrypt(){
  const text=elPlain.value;
  const m=elMode.value;
  try{
    if (m==="arabic_numbers") elOut.value = numbersToArabic(text);
    else if (m==="polybius_ar") elOut.value = polybiusDecode(text);
    else if (m==="keyed_numbers"){
      const style=document.getElementById("mapStyle").value;
      elOut.value = keyedDecode(text, style);
    }
    else if (m==="caesar_ar") elOut.value = caesarDecrypt(text, elKey.value);
    else if (m==="vigenere_ar") elOut.value = vigenereDecrypt(text, elKey.value);
    else if (m==="atbash_ar") elOut.value = atbash(text);
    else if (m==="base64") elOut.value = fromBase64Unicode(text);
  } catch(e){
    elOut.value="âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª";
  }
  renderBoxesPreview();
}

async function copyOut(){
  try{ await navigator.clipboard.writeText(elOut.value); alert("ØªÙ… Ø§Ù„Ù†Ø³Ø® âœ…"); }
  catch{ elOut.select(); document.execCommand("copy"); alert("ØªÙ… Ø§Ù„Ù†Ø³Ø® âœ…"); }
}
function swapOut(){ elPlain.value = elOut.value; elOut.value=""; renderBoxesPreview(); }
function clearAll(){
  elPlain.value=""; elOut.value=""; elKey.value="";
  const ht=document.getElementById("hintText"); if (ht) ht.value="";
  const fk=document.getElementById("fullKeyText"); if (fk) fk.value="";
  renderBoxesPreview();
}

function printCard(){
  const cipher=(elOut.value||"").trim();
  if (!cipher){ alert("Ø´ÙÙ‘Ø± Ø§Ù„Ù†Øµ Ø£ÙˆÙ„Ø§Ù‹ Ø«Ù… Ø§Ø·Ø¨Ø¹."); return; }

  const hint=(document.getElementById("hintText")?.value||"").trim();
  const printFull=document.getElementById("printFullKey").checked;
  const printBoxes=document.getElementById("printBoxes").checked;

  let fullKey="";
  if (elMode.value==="keyed_numbers" && printFull){
    const style=document.getElementById("mapStyle").value;
    fullKey = buildFullKey(style);
  }

  // build cipherHTML safely
  let cipherHTML = "";
  if (printBoxes && cipher.includes("|")){
    const boxes = cipher.split("|").filter(Boolean)
      .map(w => `<div style="border:1px solid #bbb;border-radius:12px;padding:10px 12px;font-size:18px;font-weight:800;">${w}</div>`)
      .join("");
    cipherHTML = `<div style="display:flex;gap:10px;flex-wrap:wrap;">${boxes}</div>`;
  } else {
    cipherHTML = `<div style="border:1px dashed #999;border-radius:12px;padding:12px;font-size:18px;word-break:break-word;">${cipher}</div>`;
  }

  const html = `<!doctype html><html lang="ar" dir="rtl"><head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Ø¨Ø·Ø§Ù‚Ø© Ù„ØºØ²</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Tahoma,Arial;margin:24px;line-height:1.7;}
    .box{border:2px solid #111;border-radius:14px;padding:16px;max-width:900px;}
    .hint{margin-top:12px;font-size:14px;}
    .small{color:#666;font-size:12px;margin-top:10px;}
    @media print{body{margin:0}.box{border:0;border-radius:0}}
  </style></head><body>
  <div class="box">
    <h2 style="margin:0 0 10px;">ğŸ—ï¸ Ø¨Ø·Ø§Ù‚Ø© Ù„ØºØ² â€” Ù„Ø¹Ø¨Ø© Ø§Ù„ÙƒÙ†Ø²</h2>
    ${cipherHTML}
    <div class="hint"><b>Ø§Ù„Ù…ÙØªØ§Ø­ / Ø§Ù„ØªÙ„Ù…ÙŠØ­:</b> ${hint ? hint : "(Ø§ÙƒØªØ¨ Ø§Ù„ØªÙ„Ù…ÙŠØ­ Ù…Ù† Ø§Ù„Ù…Ù†Ø¸Ù‘Ù…)"}</div>
    ${fullKey ? `<div class="small"><b>Ø§Ù„Ù…ÙØªØ§Ø­ Ø§Ù„ÙƒØ§Ù…Ù„:</b><br>${fullKey}</div>` : ""}
  </div>
  </body></html>`;

  const w=window.open("","_blank");
  w.document.open();
  w.document.write(html);
  w.document.close();
  w.focus();
  setTimeout(()=>w.print(), 200);
}

/** ===== keyed buttons ===== */
function genHint(){
  const style=document.getElementById("mapStyle").value;
  const n=document.getElementById("hintCount").value;
  document.getElementById("hintText").value = buildHint(style, n);
}
function genFull(){
  const style=document.getElementById("mapStyle").value;
  document.getElementById("fullKeyText").value = buildFullKey(style);
}

/** ===== bindings ===== */
document.getElementById("encryptBtn").addEventListener("click", encrypt);
document.getElementById("decryptBtn").addEventListener("click", decrypt);
document.getElementById("copyBtn").addEventListener("click", copyOut);
document.getElementById("swapBtn").addEventListener("click", swapOut);
document.getElementById("clearBtn").addEventListener("click", clearAll);
document.getElementById("printBtn").addEventListener("click", printCard);

document.getElementById("genHintBtn").addEventListener("click", genHint);
document.getElementById("genFullKeyBtn").addEventListener("click", genFull);

toggleHelpBtn.addEventListener("click", ()=>{
  helpPanel.classList.toggle("open");
  toggleHelpBtn.textContent = helpPanel.classList.contains("open") ? "Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø´Ø±Ø­" : "Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø´Ø±Ø­";
});

elMode.addEventListener("change", ()=>{updateHint();updateKeyedVisibility(); updateHelp(); 
  updateOutDirection();   // â† Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
});


updateHint();
updateKeyedVisibility();
updateHelp();
function updateOutDirection(){
  const m = elMode.value;
  const numericModes = ["arabic_numbers", "polybius_ar", "keyed_numbers"];
  elOut.classList.remove("ltr", "rtl");
  elOut.classList.add(numericModes.includes(m) ? "ltr" : "rtl");
}
updateOutDirection();
</script>
</body>
</html>
